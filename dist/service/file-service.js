"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fileService = void 0;
const extract_zip_1 = __importDefault(require("extract-zip"));
const fs_1 = require("fs");
const glob_1 = __importDefault(require("glob"));
const recursive_copy_1 = __importDefault(require("recursive-copy"));
const logger_1 = require("src/util/logger");
exports.fileService = {
    makeFolderIfNotExist: async (folderPath) => {
        if (await fs_1.promises.stat(folderPath).catch(() => false))
            return;
        await fs_1.promises.mkdir(folderPath);
    },
    removeFile: async (filePath) => {
        if (!(await fs_1.promises.stat(filePath).catch(() => false)))
            return;
        await fs_1.promises.rm(filePath);
    },
    removeFolder: async (folderPath) => {
        if (!(await fs_1.promises.stat(folderPath).catch(() => false)))
            return;
        await fs_1.promises.rmdir(folderPath, { recursive: true });
    },
    unzip: async (src, dest) => {
        await (0, extract_zip_1.default)(src, { dir: dest });
    },
    getFolderContent: async (path) => {
        return fs_1.promises.readdir(path);
    },
    isDirectory: async (path) => {
        try {
            const stat = await fs_1.promises.stat(path);
            return stat.isDirectory();
        }
        catch (e) {
            logger_1.logger.error('fileService.isDirectory', { error: e });
            return false;
        }
    },
    isFile: async (path) => {
        try {
            const stat = await fs_1.promises.stat(path);
            return stat.isFile();
        }
        catch (e) {
            logger_1.logger.error('fileService.isFile', { error: e });
            return false;
        }
    },
    filterFiles: async (fileFolderList) => {
        const filtered = await Promise.all(fileFolderList.map(async (f) => ((await exports.fileService.isFile(f)) ? f : undefined)));
        return filtered.filter(Boolean);
    },
    copy: async (src, dest, options = { ignore: [] }) => {
        // TODO this is to complex
        const copyContentList = await new Promise((resolve, reject) => {
            (0, glob_1.default)('**/*', { cwd: src, dot: true, nodir: true, ignore: [...options.ignore, '.bfignore'] }, (err, files) => {
                if (err)
                    return reject(err);
                return resolve(files);
            });
        });
        await Promise.all(copyContentList.map((file) => (0, recursive_copy_1.default)(`${src}/${file}`, `${dest}/${file}`)));
    },
    readFile: async (filePath) => {
        return fs_1.promises.readFile(filePath, { encoding: 'utf-8' });
    },
    getRecurringFolderContent: async (path) => {
        if (!(await exports.fileService.isDirectory(path)))
            return [];
        const folderContent = (await exports.fileService.getFolderContent(path)).map((f) => `${path}/${f}`);
        const subFolderContents = await Promise.all(folderContent.map(exports.fileService.getRecurringFolderContent));
        return [...folderContent, ...subFolderContents.flat()];
    },
    readIgnoreList: async (path) => {
        try {
            const body = await exports.fileService.readFile(`${path}/.bfignore`);
            return body
                .split('\n')
                .map((v) => v.trim())
                .filter(Boolean);
        }
        catch (e) {
            logger_1.logger.error('fileService.readIgnoreList', { error: e });
            return [];
        }
    },
    writeToFile: async (filePath, data) => {
        await fs_1.promises.writeFile(filePath, data, 'utf-8');
    },
    copyFilesIfNotExists: async (src, dest) => {
        await (0, recursive_copy_1.default)(src, dest, { overwrite: false, dot: true });
    },
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZS1zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3NlcnZpY2UvZmlsZS1zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDhEQUFvQztBQUNwQywyQkFBbUM7QUFDbkMsZ0RBQXVCO0FBQ3ZCLG9FQUFpQztBQUNqQyw0Q0FBd0M7QUFFM0IsUUFBQSxXQUFXLEdBQUc7SUFDekIsb0JBQW9CLEVBQUUsS0FBSyxFQUFFLFVBQWtCLEVBQWlCLEVBQUU7UUFDaEUsSUFBSSxNQUFNLGFBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQztZQUFFLE9BQU07UUFDeEQsTUFBTSxhQUFFLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFBO0lBQzVCLENBQUM7SUFDRCxVQUFVLEVBQUUsS0FBSyxFQUFFLFFBQWdCLEVBQWlCLEVBQUU7UUFDcEQsSUFBSSxDQUFDLENBQUMsTUFBTSxhQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUFFLE9BQU07UUFDekQsTUFBTSxhQUFFLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFBO0lBQ3ZCLENBQUM7SUFDRCxZQUFZLEVBQUUsS0FBSyxFQUFFLFVBQWtCLEVBQWlCLEVBQUU7UUFDeEQsSUFBSSxDQUFDLENBQUMsTUFBTSxhQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUFFLE9BQU07UUFDM0QsTUFBTSxhQUFFLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFBO0lBQ2pELENBQUM7SUFDRCxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQVcsRUFBRSxJ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Q0gsQ0FBQztJQUNELFdBQVcsRUFBRSxLQUFLLEVBQUUsUUFBZ0IsRUFBRSxJQUFZLEVBQWlCLEVBQUU7UUFDbkUsTUFBTSxhQUFFLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUE7SUFDN0MsQ0FBQztJQUNELG9CQUFvQixFQUFFLEtBQUssRUFBRSxHQUFXLEVBQUUsSUFBWSxFQUFpQixFQUFFO1FBQ3ZFLE1BQU0sSUFBQSx3QkFBSSxFQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFBO0lBQ3hELENBQUM7Q0FDRixDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGV4dHJhY3RaaXAgZnJvbSAnZXh0cmFjdC16aXAnXG5pbXBvcnQgeyBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJ1xuaW1wb3J0IGdsb2IgZnJvbSAnZ2xvYidcbmltcG9ydCBjb3B5IGZyb20gJ3JlY3Vyc2l2ZS1jb3B5J1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnc3JjL3V0aWwvbG9nZ2VyJ1xuXG5leHBvcnQgY29uc3QgZmlsZVNlcnZpY2UgPSB7XG4gIG1ha2VGb2xkZXJJZk5vdEV4aXN0OiBhc3luYyAoZm9sZGVyUGF0aDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgaWYgKGF3YWl0IGZzLnN0YXQoZm9sZGVyUGF0aCkuY2F0Y2goKCkgPT4gZmFsc2UpKSByZXR1cm5cbiAgICBhd2FpdCBmcy5ta2Rpcihmb2xkZXJQYXRoKVxuICB9LFxuICByZW1vdmVGaWxlOiBhc3luYyAoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmICghKGF3YWl0IGZzLnN0YXQoZmlsZVBhdGgpLmNhdGNoKCgpID0+IGZhbHNlKSkpIHJldHVyblxuICAgIGF3YWl0IGZzLnJtKGZpbGVQYXRoKVxuICB9LFxuICByZW1vdmVGb2xkZXI6IGFzeW5jIChmb2xkZXJQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICBpZiAoIShhd2FpdCBmcy5zdGF0KGZvbGRlclBhdGgpLmNhdGNoKCgpID0+IGZhbHNlKSkpIHJldHVyblxuICAgIGF3YWl0IGZzLnJtZGlyKGZvbGRlclBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG4gIH0sXG4gIHVuemlwOiBhc3luYyAoc3JjOiBzdHJpbmcsIGRlc3Q6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGF3YWl0IGV4dHJhY3RaaXAoc3JjLCB7IGRpcjogZGVzdCB9KVxuICB9LFxuICBnZXRGb2xkZXJDb250ZW50OiBhc3luYyAocGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4gPT4ge1xuICAgIHJldHVybiBmcy5yZWFkZGlyKHBhdGgpXG4gIH0sXG4gIGlzRGlyZWN0b3J5OiBhc3luYyAocGF0aDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXQgPSBhd2FpdCBmcy5zdGF0KHBhdGgpXG4gICAgICByZXR1cm4gc3RhdC5pc0RpcmVjdG9yeSgpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLmVycm9yKCdmaWxlU2VydmljZS5pc0RpcmVjdG9yeScsIHsgZXJyb3I6IGUgfSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgaXNGaWxlOiBhc3luYyAocGF0aDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXQgPSBhd2FpdCBmcy5zdGF0KHBhdGgpXG4gICAgICByZXR1cm4gc3RhdC5pc0ZpbGUoKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignZmlsZVNlcnZpY2UuaXNGaWxlJywgeyBlcnJvcjogZSB9KVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9LFxuICBmaWx0ZXJGaWxlczogYXN5bmMgKGZpbGVGb2xkZXJMaXN0OiBzdHJpbmdbXSk6IFByb21pc2U8c3RyaW5nW10+ID0+IHtcbiAgICBjb25zdCBmaWx0ZXJlZCA9IGF3YWl0IFByb21pc2UuYWxsKGZpbGVGb2xkZXJMaXN0Lm1hcChhc3luYyAoZikgPT4gKChhd2FpdCBmaWxlU2VydmljZS5pc0ZpbGUoZikpID8gZiA6IHVuZGVmaW5lZCkpKVxuICAgIHJldHVybiBmaWx0ZXJlZC5maWx0ZXIoQm9vbGVhbikgYXMgc3RyaW5nW11cbiAgfSxcbiAgY29weTogYXN5bmMgKHNyYzogc3RyaW5nLCBkZXN0OiBzdHJpbmcsIG9wdGlvbnM6IHsgaWdub3JlOiBzdHJpbmdbXSB9ID0geyBpZ25vcmU6IFtdIH0pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAvLyBUT0RPIHRoaXMgaXMgdG8gY29tcGxleFxuICAgIGNvbnN0IGNvcHlDb250ZW50TGlzdCA9IGF3YWl0IG5ldyBQcm9taXNlPHN0cmluZ1tdPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBnbG9iKCcqKi8qJywgeyBjd2Q6IHNyYywgZG90OiB0cnVlLCBub2RpcjogdHJ1ZSwgaWdub3JlOiBbLi4ub3B0aW9ucy5pZ25vcmUsICcuYmZpZ25vcmUnXSB9LCAoZXJyLCBmaWxlcykgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycilcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoZmlsZXMpXG4gICAgICB9KVxuICAgIH0pXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoY29weUNvbnRlbnRMaXN0Lm1hcCgoZmlsZSkgPT4gY29weShgJHtzcmN9LyR7ZmlsZX1gLCBgJHtkZXN0fS8ke2ZpbGV9YCkpKVxuICB9LFxuICByZWFkRmlsZTogYXN5bmMgKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZShmaWxlUGF0aCwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KVxuICB9LFxuICBnZXRSZWN1cnJpbmdGb2xkZXJDb250ZW50OiBhc3luYyAocGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4gPT4ge1xuICAgIGlmICghKGF3YWl0IGZpbGVTZXJ2aWNlLmlzRGlyZWN0b3J5KHBhdGgpKSkgcmV0dXJuIFtdXG4gICAgY29uc3QgZm9sZGVyQ29udGVudCA9IChhd2FpdCBmaWxlU2VydmljZS5nZXRGb2xkZXJDb250ZW50KHBhdGgpKS5tYXAoKGYpID0+IGAke3BhdGh9LyR7Zn1gKVxuICAgIGNvbnN0IHN1YkZvbGRlckNvbnRlbnRzID0gYXdhaXQgUHJvbWlzZS5hbGwoZm9sZGVyQ29udGVudC5tYXAoZmlsZVNlcnZpY2UuZ2V0UmVjdXJyaW5nRm9sZGVyQ29udGVudCkpXG4gICAgcmV0dXJuIFsuLi5mb2xkZXJDb250ZW50LCAuLi5zdWJGb2xkZXJDb250ZW50cy5mbGF0KCldXG4gIH0sXG4gIHJlYWRJZ25vcmVMaXN0OiBhc3luYyAocGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBib2R5ID0gYXdhaXQgZmlsZVNlcnZpY2UucmVhZEZpbGUoYCR7cGF0aH0vLmJmaWdub3JlYClcbiAgICAgIHJldHVybiBib2R5XG4gICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgLm1hcCgodikgPT4gdi50cmltKCkpXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ2ZpbGVTZXJ2aWNlLnJlYWRJZ25vcmVMaXN0JywgeyBlcnJvcjogZSB9KVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICB9LFxuICB3cml0ZVRvRmlsZTogYXN5bmMgKGZpbGVQYXRoOiBzdHJpbmcsIGRhdGE6IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShmaWxlUGF0aCwgZGF0YSwgJ3V0Zi04JylcbiAgfSxcbiAgY29weUZpbGVzSWZOb3RFeGlzdHM6IGFzeW5jIChzcmM6IHN0cmluZywgZGVzdDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgYXdhaXQgY29weShzcmMsIGRlc3QsIHsgb3ZlcndyaXRlOiBmYWxzZSwgZG90OiB0cnVlIH0pXG4gIH0sXG59XG4iXX0=